#!/usr/bin/env python

import argparse
import re
import sys

from dataclasses import dataclass, field
from typing import List


@dataclass
class Argument:

    name: str = ""
    desc: str = ""

    @property
    def zsh_arg(self):
        return f"':{self.name}:'"


@dataclass
class Option:

    name: str = ""
    alt_name: str = ""
    desc: str = ""
    arg: str = ""

    @property
    def zsh_arg(self):
        """
        Represent an option as a zsh _arguments element.
        """

        if self.alt_name:
            exclusions = f"({self.name} {self.alt_name})"
            if self.arg:
                opt_name = f"{{{self.name}+,{self.alt_name}=}}"
            else:
                opt_name = f"{{{self.name},{self.alt_name}}}"
        else:
            exclusions = f"({self.name})"
            if self.arg:
                opt_name = f"{self.name}="
            else:
                opt_name = f"{self.name}"
        desc = f"[{self.desc}]"
        out = f"'{exclusions}'{opt_name}'{desc}'"

        return out


@dataclass
class Parser:

    args: List[Argument] = field(default_factory=list)
    opts:  List[Option] = field(default_factory=list)

    @property
    def zsh_args(self):
        out = ""
        for opt in self.opts:
            out += opt.zsh_arg + "\n"
        out += "\n"
        for arg in self.args:
            out += arg.zsh_arg + "\n"
        out = out[:-1]
        return out


class DevtoolSubcommandParser(Parser):

    args_re = re.compile(
        r"^  (?P<name>[a-zA-Z]+)"  # argument name
        r"\s+"                  # spaces between name and description
        r"(?P<desc>\S.+)$"      # the description
    )

    opts_re_nodesc = re.compile(
        r"^  (?P<opt1>[a-zA-Z-]+)"     # the first opt
        r"( (?P<opt_arg>[A-Z_]+))?"    # the first option argument (optional)
        r"( \[[A-Z_]+ \.\.\.\])?"      # additional first option arguments (optional)
        r"(, (?P<opt2>[a-zA-Z-]+))?"   # the second opt (optional)
        r"( [A-Z_]+)?"                # the second option argument (optional)
        r"( \[[A-Z_]+ \.\.\.\])?$"      # additional second option arguments (optional)
    )

    opts_re_desc = re.compile(
        r"^  (?P<opt1>[a-zA-Z-]+)"     # the first opt
        r"(( (?P<opt_arg>[A-Z_]+))"    # the first option argument (optional)
        r"|( \.\.\.))?"                # remainder (optional)
        r"(, (?P<opt2>[a-zA-Z-]+))?"   # the second opt (optional)
        r"( [A-Z_]+)?"                 # the second option argument (optional)
        r"\s+"                         # spaces between opts and description
        r"(?P<desc>\S.+)$"             # the description
    )

    def parse_help(self, help_txt: str) -> None:

        in_args = False
        in_opts = False
        desc_next_line = False
        prev_opt = Option()

        for line in help_txt.splitlines():

            if line.startswith("arguments:"):
                in_args = True
                in_opts = False
                continue

            if line.startswith("options:"):
                in_args = False
                in_opts = True
                continue

            if in_args:
                if m := re.match(self.args_re, line):
                    self.args += [Argument(name=m.group("name"),
                                           desc=m.group("desc"))]

            if in_opts:
                m_desc = re.match(self.opts_re_desc, line)
                m_nodesc = re.match(self.opts_re_nodesc, line)
                if m_nodesc:
                    m = m_nodesc
                else:
                    m = m_desc

                if desc_next_line:
                    desc = line.strip()
                    prev_opt.desc = desc[0].lower() + desc[1:]
                    desc_next_line = False

                elif m:
                    opt = Option()
                    desc = ""
                    if m_desc and not m_nodesc:
                        desc = m.group("desc")
                    if desc:
                        opt.desc = desc[0].lower() + desc[1:]
                    opt.arg = m.group("opt_arg")
                    opt1, opt2 = m.group("opt1"), m.group("opt2")
                    if opt2 is not None:
                        if opt2.startswith("--"):
                            opt.name = opt1
                            opt.alt_name = opt2
                        else:
                            opt.name = opt2
                            opt.alt_name = opt1
                    else:
                        opt.name = opt1
                    self.opts += [opt]
                    if m_nodesc is not None:
                        prev_opt = opt
                        desc_next_line = True

                m_desc, m_nodesc = None, None


def display_zsh_opts(text: str, indent: int = 0):
    for line in text.splitlines():
        print(" " * indent + line)


def parse_arguments() -> argparse.ArgumentParser:

    parser = argparse.ArgumentParser(
        description="Parse bitbake-like tools help messages")

    parser.add_argument("--to-zsh-args",
                        action="store_true",
                        default=False,
                        dest="to_zsh",
                        help="Print parsed help as zsh arguments")

    parser.add_argument("--parse-mode",
                        choices=[
                            "devtool.subcommand",
                        ],
                        dest="mode",
                        required=True,
                        help="Parsing mode")

    parser.add_argument("--indent",
                        type=int,
                        default=0,
                        help="Parsing mode")

    return parser


def main():

    aparser = parse_arguments()
    pargs = aparser.parse_args()

    help_txt = sys.stdin.read()
    if not help_txt:
        print("No test passed in stdin!")
        aparser.print_usage()
        exit(1)

    parser = None

    if pargs.mode == "devtool.subcommand":
        parser = DevtoolSubcommandParser()
        parser.parse_help(help_txt)

    if pargs.to_zsh and parser is not None:
        display_zsh_opts(parser.zsh_args, pargs.indent)


if __name__ == "__main__":
    main()
